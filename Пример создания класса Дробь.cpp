/*
Пример создания класса Дробь
Ниже приведено решение задачи создания класса рациональной дроби с подробными комментариями.Пример иллюстрирует проектирование, описание и использование классов и объектов.В классе наглядно продемонстрировано создание и применение конструкторов, деструкторов, собственных функций, а также проектирование интерфейса : написание функций для обращения к собственным данным объектов класса с целью ограничения "несанкционированного доступа", перегрузка операций, как компонентных функций класса, так и дружественных функций - операций.В примере введена статическая переменная - счетчик объектов класса и статическая функция получения ее значения.

Обратите внимание, что все функции имеют внутри описания класса только объявления, а определяются позже, кроме setNumber(), которая содержит определение непосредственно в объявлении класса - такая функция является подставляемой, т.е.ее код подставляется в каждой точке обращения к ней.Чаще всего это неудобно, так как увеличивает объем программы(исполняемого кода), поэтому рекомендуется использовать такой прием только для очень коротких функций, например, как приведенная - которая отвечает лишь за возврат существующего значения компонента класса.
*/



//подключение стандартных библиотек

#include <iostream.h>
#include <math.h>



//ОПИСАНИЕ КЛАССА

//описание класса - дробь

class fraction {

    // числитель и знаменатель - компонентные данные объектов

    int numerator, denominator;

    //собственная функция для сокращения неправильной дроби

    void reduce();

    //счетчик объектов класса - статическое данное класса

    static int N;

public:

    //далее описываются доступные компоненты интерфейса

    /*конструктор класса с параметрами по умолчанию, который обеспечивает вызов конструктора без параметров, при этом дробь инициализируется 1; с одним параметром - числителем для создания дробного представления целого числа; наконец, с двумя параметрами - числителем и знаменателем для инициализации правильной дроби*/

    fraction(int n = 0, int d = 1);

    //конструктор копирования

    fraction(fraction& a);

    //деструктор

    ~fraction();

    /* так как данные класса и его объектов являются собственными, то мы объявляем три функции для получения значений соответствующих данных, причем для статического компонента N функция также будет статической*/

    int getDenom();

    int getNumer();

    static int getN() { return N; }

    /*далее определена функция установки новых значений числителя и знаменателя объекта*/

    void setFraction(int n, int m);

    //функция получения действительного значения дроби

    float real();

    //функция добавления значения дроби-параметра к значению объекта

    void add(fraction& a);

    //функция обращения дроби

    void obrat();

    // перегрузка операции присваивания

    fraction& operator =(const fraction& a);

    //перегрузка префиксной и постфиксной операций инкремента

    fraction operator ++();

    fraction operator ++(int);

    /*объявление друзьями класса функций перегрузки операций сложения, умножения дробей и вывода дроби в поток */

    friend  fraction operator +(fraction b, fraction a);

    friend  fraction operator *(fraction b, fraction a);

    friend  ostream& operator <<(ostream& out, fraction a);

};



//ОПРЕДЕЛЕНИЕ КЛАССА

/* при определении всех компонент класса  необходимо указывать их полное имя через операцию разрешения области видимости*/



/*обязательное объявление статической компоненты класса с инициализацией, и единственной место в программе, где к ней можно обратиться непосредственно по имени, так как она является собственной*/

int fraction::N = 0;

/* в конструкторе инициализируются компоненты объекта по получаемым параметрам, дробь приводится к стандартному виду - сокращается, и увеличивается счетчик экземпляров класса; в данном случае собственные данные объекта инициализируются с использованием присваивания значений внутри тела конструктора*/

fraction::fraction(int n, int d)

{
    denominator = d; numerator = n; reduce(); N++;
}

/* в конструкторе копирования компоненты объекта копируются из дроби-параметра, и увеличивается счетчик экземпляров класса; обратите внимание, что компоненты объекта приемника указываются только по имени, а те же компоненты для объекта-параметра получаются путем указания полного имени: имени объекта, операции . и имени компонента */

fraction::fraction(fraction& a)

{
    numerator = a.numerator; denominator = a.denominator; N++;
}

/*деструктор отвечает только за уменьшение количества объектов */

fraction::~fraction() { N--; }

/*функции get* возвращают значение соответсвующнго компонента*/

int fraction::getNumer() { return numerator; }

int fraction::getDenom() { return denominator; }

/* функция установки значений компонент объекта проверяет корректность входных параметров, а после инициализации сокращает дробь*/

void fraction::setFraction(int n, int m)

{
    if (m) { denominator = m; numerator = n; reduce(); }
}

/* функция преобразует дробь к вещественному типу float, используя приведение типа для знаменателя и обычное деление; обратите внимание, что обращение к компонентам объекта-приемника, которому будет послано это сообщение, происходит только по имени*/

float fraction::real() { return numerator / ((float)(denominator)); }

/* функция добавления значения получает в качестве параметра ссылку на добавляемый объект, что, в частности, экономит на копировании объекта; после добавления дробь сокращается*/

void fraction::add(fraction& a)

{
    numerator = numerator * a.denominator + a.numerator * denominator;

    denominator *= a.denominator;

    reduce();
}

/* обратите внимание на эту функцию обращения дроби - ее содержимое это вызов трех компонентных функций объект */

void fraction::obrat() { setFraction(getDenom(), getNumer()); }

/*собственная функция сокращения дроби вызывается только из методов объекта для приведения дроби к стандартному виду, используя алгоритм Евклида для нахождения НОД */

void fraction::reduce()

{
    if ((!numerator) || (!denominator))  return;

    int a = abs(numerator), b = abs(denominator);

    while (a != b)     if (a > b) a -= b;  else b -= a;

    numerator /= a;  denominator /= b;
}

/* перегрузка операции присваивания реализована в виде компонентной функции, которая получает в качестве параметра ссылку на присваиваемый объект и отличается от конструктора копирования только проверкой на отсутствие копирования самого объекта в  себя и возвращением результата - ссылки на сам объект для сохранения преемственности стандартной операции присваивания */

fraction& fraction::operator =(const fraction& a)

{
    if (&a == this)return *this;

    numerator = a.numerator;

    denominator = a.denominator;

    return *this;
}

/*перегрузка операций инкремента, реализованная как компонентные функции, отличается лишь последовательностью возврата значения объекта и увеличения значения объекта на 1; обратите внимание на конструктор дроби для целого числа 1 с единственным параметром- числителем*/

fraction fraction::operator ++()

{
    fraction e(1), temp = *this; add(e); return temp;
}

fraction fraction::operator ++(int)

{
    fraction e(1); add(e); return *this;
}

/*перегрузка операции помещения в поток использует стандартный класс потока вывода в качестве левого операнда и дробь в качестве правого; это пример дружественной функции, которая имеет доступ к закрытым данным класса дроби; при реализации стоит обратить внимание, что функция должна возвращать ссылку на поток вывода для возможности организации цепочки помещения в поток*/

ostream& operator <<(ostream& out, fraction a)

{
    return out << a.numerator << "/" << a.denominator;
}

/* дружественные функции перегрузки операций сложения и умножения имеют доступ непосредственно к собственным компонентам своих операндов-дробей; результат операции - объект-дробь возвращается обычным образом */

fraction operator +(fraction b, fraction a)

{
    fraction S(b.numerator * a.denominator + a.numerator * b.denominator,

        b.denominator * a.denominator); return S;
}



fraction operator *(fraction b, fraction a)

{
    fraction S(b.numerator * a.numerator,

        b.denominator * a.denominator); return S;
}



//ОПИСАНИЕ ПРОГРАММЫ-ТЕСТА ДЛЯ КЛАССА ДРОБЬ

void main()

{

    /*создаем четыре объекта класса Дробь (A, B, D, E) и один указатель на объект (C), при создании объектов используется вызов конструктора, причем, если часть или все параметры опущены, то используются значения по умолчанию, описанные в классе*/

    fraction A(5), B(5, 3), * C, D(1, 3), E;

    /*свяжем указатель C с объектом A*/

    C = &A;

    /*используя перегруженную операцию помещения в поток, отобразим на экране созданные объекты и проверим корректность конструктора */

    cout << "\nA=" << A << "\nB=" << B << "\n*C=" << (*C)

        << "\nD=" << D << "\nE=" << E << endl;

    /*добавим дробь B к объекту, на который указывает C (т.е. к A), используя операцию ->, и выведем результат на экран */

    C->add(B);

    cout << "\nC->add(B)\t*C=" << (*C) << " == Anew=" << A << endl;

    /*используем перегруженную операцию сложения для вычисления суммы дробей A и D, результат присваивается объекту E, при этом вызывается перегруженная компонентная операция-функция присваивания*/

    E = A + D;

    cout << "\nE=A+D=" << A << "+" << D << "=" << E << endl;

    /*проверяем корректность работы префиксной и постфиксной операций инкремента (при этом также вызывается перегруженная операция присваивания*/

    A = ++E;

    cout << "\nA=++E: A=" << A << " | E=" << E;

    A = E++;

    cout << "\nA=E++: A=" << A << " | E=" << E << endl;

    /*как будет вести себя дробь, если попытаться сложить ее с целым числом? Сначала число 5 преобразуется к типу fraction - создается новый временный объект с числителем 5 и знаменателем 1 (для этого автоматически используется конструктор и параметр для знаменателя по умолчанию), а уже потом дроби суммируются перегруженной операцией сложения и результат присваивается объекту E */

    E = 5 + B;

    cout << "\nB+5=" << B << "+5" << "=" << E << endl;

    /*изменим значение дроби D, используя функцию setFraction, и найдем вещественное значение дроби */

    D.setFraction(2, 12);

    cout << "\nD=" << D << " =" << D.real();

    /*проиллюстрируем работу компонентной функции обращения дроби*/

    D.obrat();

    cout << "\n1/D=" << D << endl;

    /*получим значение счетчика объектов - статического данного класса, используя статическую функцию класса*/

    cout << "\nN=" << fraction::getN();

    /*создадим новый объект, используя операцию new, в скобочках необходимо указать параметры для конструктора, который будет вызван автоматически*/

    C = new fraction(6, 18);

    /*отобразим новый объект и изменившийся счетчик класса*/

    cout << "\nnew: *C=" << (*C) << " \t N=" << fraction::getN();

    /*удалим новый объект операцией delete, при этом автоматически вызывается деструктор, поэтому измениться статический счетчик*/

    delete C;

    /*проверим значение компонента класса N, обратите внимание, что раньше мы обращались к статической функции класса через имя класса с использованием операции разрешения области видимости, а теперь обращаемся через объект класса и операцию .*/

    cout << "\ndelete: N=" << A.getN() << endl;

}


